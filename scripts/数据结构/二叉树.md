#### [226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

翻转一棵二叉树。

示例：

输入：

```
     4
   /   \
  2     7
 / \   / \
1   3 6   9
```

输出：

```
     4
   /   \
  7     2
 / \   / \
9   6 3   1
```

来源：力扣（LeetCode）

方法一：递归

简单地考虑根节点的root左右子节点互换，并且不断重复，用深度优先算法（DFS）。

```c++
    /**
     * Definition for a binary tree node.
     * struct TreeNode {
     *     int val;
     *     TreeNode *left;
     *     TreeNode *right;
     *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
     * };
     */
    class Solution {
    public:
        TreeNode* invertTree(TreeNode* root) {
            if (root == NULL) {
                return NULL;
            }

            TreeNode* left = invertTree(root->left);
            TreeNode* right = invertTree(root->right);
            root->left = right;
            root->right = left;
            return root;
        }
    };
```

方法二：迭代

建立一个队列，将没有互换左右子节点的根节点放入队列，弹出已经互换子节点的根节点。直到队列为空，返回最开始的根节点。

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if (root == NULL) {
            return NULL;
        }

        queue<TreeNode*> my_queue;
        my_queue.push(root);
        while (!my_queue.empty()) {
            TreeNode* cur = my_queue.front();
            my_queue.pop();
            swap(cur->right, cur->left);
            if(cur->left) my_queue.push(cur->left);
            if(cur->right) my_queue.push(cur->right);
        }
        return root;
    }
};
```

#### [剑指 Offer 07. 重建二叉树](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)

输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。

 

例如，给出

```
前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
```

返回如下的二叉树：

```
    3
   / \
  9  20
    /  \
   15   7
```

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof
![](/home/zhouhua/Pictures/算法.png)

树的前序便利顺序是根节点，左子树，右子树，中序遍历的顺序是左子树，根节点，右子树。

递归的关键点：

1. 前序遍历的第一个结果是树的根节点。

2. 寻找中序遍历的根节点的位置，左边部分为树的左子树，右边为树的右子树。

3. 遍历整个树，

   