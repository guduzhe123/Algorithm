# 链表的增删查改

1. #### [两数相加](https://leetcode-cn.com/problems/add-two-numbers/)

给出两个 **非空** 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 **逆序** 的方式存储的，并且它们的每个节点只能存储 **一位** 数字。

如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。

您可以假设除了数字 0 之外，这两个数都不会以 0 开头。

**示例：**

```
输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)
输出：7 -> 0 -> 8
原因：342 + 465 = 807
```

伪代码：

- 当前节点初始化为哑结点

- 将进位carry初始化为0

- 遍历了l1和l2直到尾部

  - 将x设置为节点l1的值，如果已经到达l1的尾部，则设置为0；
  - 将y设置为节点l2的值，如果已经达到l2的尾部，则设置为0；
  - 设置sum=x+y+carry;
  - 更新进位，carry=sum/10;
  - 创建一个数值为sum % 10 的节点，设置为当前节点的下一个节点，当前节点前进到下一个节点。
  - 将l1和l2前进到下一个节点。

- 检测carry是否等于1，如果成立，则列表追加一个数字1的新节点。

- 返回哑节点的下一个节点。

  代码如下：

  

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode* root = new ListNode(-1);
        ListNode* result = root;
        int carry = 0, sum = 0;
        while(l1 != NULL || l2 != NULL) {
            int x = (l1 != NULL) ? l1->val : 0;
            int y = (l2 != NULL) ? l2->val : 0;
            sum = x + y + carry;
            carry = sum / 10;
            result->next = new ListNode(sum % 10);
            result = result->next;

            if (l1 != NULL) l1 = l1->next;
            if (l2 != NULL) l2 = l2->next;
        }
        if (carry != 0) result->next = new ListNode(1);
        return root->next;
    }
};
```





1. #### [19. 删除链表的倒数第N个节点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。

示例：

```
给定一个链表: 1->2->3->4->5, 和 n = 2.

当删除了倒数第二个节点后，链表变为 1->2->3->5.
```


说明：

给定的 n 保证是有效的。

进阶：

你能尝试使用一趟扫描实现吗？

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

解法：快慢指针：







1. #### 编写一个函数，检查输入的链表是否是回文的。

示例 1：

```
输入： 1->2
输出： false 
示例 2：

输入： 1->2->2->1
输出： true 
```


进阶：
你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/palindrome-linked-list-lcci
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

方法1：反转链表：

反转链表，逐个比较两个链表的节点，若一致则为回文链表。

```cpp
struct ListNode {
	int val;
    ListNode* next;
    ListNode(int x) : val(x), next(NULL){}
};
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        ListNode* first = reversList(head);
        return isEqual(first, head);
    }
    
    ListNode* reversList(ListNode* head) {
        ListNode* pre = head;
        while (head != NULL) {
            ListNode* cur = new ListNode(head->val);
            cur->next = pre;
            pre = cur;
            head = head->next;
        }
        return pre;
    }
    
    bool isEqual(ListNode* first, ListNode* second) {
        while (first != NULL && second != NULL) {
            if (first->val != second->val) return false;
            first = first->next;
            second = second->next;
        }
        return first == NULL && second == NULL;
    }
    
}
```

方法2：双指针，快慢指针：

只需比较前一半与后一半是否一样。